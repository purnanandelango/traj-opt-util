/**
 * This file is generated by FiOrdOs, a program licensed under GPL
 * by copyright holder Automatic Control Laboratory, ETH Zurich.
 * 
 * If you are interested in using this file commercially,
 * please contact the copyright holder.
 */

#include "ex2_solver.h"
#include <stdio.h>
#include <math.h>
#include <string.h>

#ifdef MATLAB_MEX_FILE
#include "mex.h"
#endif

/* <<< print >>> */
static void printArray(realtype *arr, int dim) {
  int i;
  printf("[\n"); ;
  for (i=0; i<dim; i++) {
    printf("%8.16e\n",*arr++);
  }
  printf("]\n\n");
}

static void printArrayNamed(realtype *arr, int dim, char *txt) {
  printf("%s = ",txt);
  printArray(arr,dim);
}

/* <<< copy vectors >>> */
static void copyvec30(realtype *dest, const realtype *src) {
    {
        int i;
        for (i=0; i<30; ++i) {
            dest[i] = src[i];
        }
    }
}
static void copyvec20(realtype *dest, const realtype *src) {
    {
        int i;
        for (i=0; i<20; ++i) {
            dest[i] = src[i];
        }
    }
}

/* <<< projection >>> */
static void algoInner_project(realtype *thevec, ex2_Work *work, ex2_Params *params) {
    realtype *theveci;

    /* ====== EssBox X1 ====== */
    theveci = thevec;
    /* ------ projection ------ */
    {
        int icoord;
        for (icoord=0; icoord<1; ++icoord) {
          if (theveci[icoord] < work->Prob.X1.l[icoord]) {
            theveci[icoord] = work->Prob.X1.l[icoord];
          }
          else if (theveci[icoord] > work->Prob.X1.u[icoord]) {
            theveci[icoord] = work->Prob.X1.u[icoord];
          }
        }
    }
    /* ====== EssBox X2 ====== */
    theveci = thevec+1;
    /* ------ projection ------ */
    {
        int icoord;
        for (icoord=0; icoord<1; ++icoord) {
          if (theveci[icoord] < work->Prob.X2.l[icoord]) {
            theveci[icoord] = work->Prob.X2.l[icoord];
          }
          else if (theveci[icoord] > work->Prob.X2.u[icoord]) {
            theveci[icoord] = work->Prob.X2.u[icoord];
          }
        }
    }
    /* ====== EssBox X3 ====== */
    theveci = thevec+2;
    /* ------ projection ------ */
    {
        int icoord;
        for (icoord=0; icoord<1; ++icoord) {
          if (theveci[icoord] < work->Prob.X3.l[icoord]) {
            theveci[icoord] = work->Prob.X3.l[icoord];
          }
          else if (theveci[icoord] > work->Prob.X3.u[icoord]) {
            theveci[icoord] = work->Prob.X3.u[icoord];
          }
        }
    }
    /* ====== EssBox X4 ====== */
    theveci = thevec+3;
    /* ------ projection ------ */
    {
        int icoord;
        for (icoord=0; icoord<1; ++icoord) {
          if (theveci[icoord] < work->Prob.X4.l[icoord]) {
            theveci[icoord] = work->Prob.X4.l[icoord];
          }
          else if (theveci[icoord] > work->Prob.X4.u[icoord]) {
            theveci[icoord] = work->Prob.X4.u[icoord];
          }
        }
    }
    /* ====== EssBox X5 ====== */
    theveci = thevec+4;
    /* ------ projection ------ */
    {
        int icoord;
        for (icoord=0; icoord<1; ++icoord) {
          if (theveci[icoord] < work->Prob.X5.l[icoord]) {
            theveci[icoord] = work->Prob.X5.l[icoord];
          }
          else if (theveci[icoord] > work->Prob.X5.u[icoord]) {
            theveci[icoord] = work->Prob.X5.u[icoord];
          }
        }
    }
    /* ====== EssBox X6 ====== */
    theveci = thevec+5;
    /* ------ projection ------ */
    {
        int icoord;
        for (icoord=0; icoord<1; ++icoord) {
          if (theveci[icoord] < work->Prob.X6.l[icoord]) {
            theveci[icoord] = work->Prob.X6.l[icoord];
          }
          else if (theveci[icoord] > work->Prob.X6.u[icoord]) {
            theveci[icoord] = work->Prob.X6.u[icoord];
          }
        }
    }
    /* ====== EssBox X7 ====== */
    theveci = thevec+6;
    /* ------ projection ------ */
    {
        int icoord;
        for (icoord=0; icoord<1; ++icoord) {
          if (theveci[icoord] < work->Prob.X7.l[icoord]) {
            theveci[icoord] = work->Prob.X7.l[icoord];
          }
          else if (theveci[icoord] > work->Prob.X7.u[icoord]) {
            theveci[icoord] = work->Prob.X7.u[icoord];
          }
        }
    }
    /* ====== EssBox X8 ====== */
    theveci = thevec+7;
    /* ------ projection ------ */
    {
        int icoord;
        for (icoord=0; icoord<1; ++icoord) {
          if (theveci[icoord] < work->Prob.X8.l[icoord]) {
            theveci[icoord] = work->Prob.X8.l[icoord];
          }
          else if (theveci[icoord] > work->Prob.X8.u[icoord]) {
            theveci[icoord] = work->Prob.X8.u[icoord];
          }
        }
    }
    /* ====== EssBox X9 ====== */
    theveci = thevec+8;
    /* ------ projection ------ */
    {
        int icoord;
        for (icoord=0; icoord<1; ++icoord) {
          if (theveci[icoord] < work->Prob.X9.l[icoord]) {
            theveci[icoord] = work->Prob.X9.l[icoord];
          }
          else if (theveci[icoord] > work->Prob.X9.u[icoord]) {
            theveci[icoord] = work->Prob.X9.u[icoord];
          }
        }
    }
    /* ====== EssBox X10 ====== */
    theveci = thevec+9;
    /* ------ projection ------ */
    {
        int icoord;
        for (icoord=0; icoord<1; ++icoord) {
          if (theveci[icoord] < work->Prob.X10.l[icoord]) {
            theveci[icoord] = work->Prob.X10.l[icoord];
          }
          else if (theveci[icoord] > work->Prob.X10.u[icoord]) {
            theveci[icoord] = work->Prob.X10.u[icoord];
          }
        }
    }
    /* ====== EssBox X11 ====== */
    theveci = thevec+10;
    /* ------ projection ------ */
    {
        int icoord;
        for (icoord=0; icoord<2; ++icoord) {
          if (theveci[icoord] < work->Prob.X11.l[icoord]) {
            theveci[icoord] = work->Prob.X11.l[icoord];
          }
          else if (theveci[icoord] > work->Prob.X11.u[icoord]) {
            theveci[icoord] = work->Prob.X11.u[icoord];
          }
        }
    }
    /* ====== EssBox X12 ====== */
    theveci = thevec+12;
    /* ------ projection ------ */
    {
        int icoord;
        for (icoord=0; icoord<2; ++icoord) {
          if (theveci[icoord] < work->Prob.X12.l[icoord]) {
            theveci[icoord] = work->Prob.X12.l[icoord];
          }
          else if (theveci[icoord] > work->Prob.X12.u[icoord]) {
            theveci[icoord] = work->Prob.X12.u[icoord];
          }
        }
    }
    /* ====== EssBox X13 ====== */
    theveci = thevec+14;
    /* ------ projection ------ */
    {
        int icoord;
        for (icoord=0; icoord<2; ++icoord) {
          if (theveci[icoord] < work->Prob.X13.l[icoord]) {
            theveci[icoord] = work->Prob.X13.l[icoord];
          }
          else if (theveci[icoord] > work->Prob.X13.u[icoord]) {
            theveci[icoord] = work->Prob.X13.u[icoord];
          }
        }
    }
    /* ====== EssBox X14 ====== */
    theveci = thevec+16;
    /* ------ projection ------ */
    {
        int icoord;
        for (icoord=0; icoord<2; ++icoord) {
          if (theveci[icoord] < work->Prob.X14.l[icoord]) {
            theveci[icoord] = work->Prob.X14.l[icoord];
          }
          else if (theveci[icoord] > work->Prob.X14.u[icoord]) {
            theveci[icoord] = work->Prob.X14.u[icoord];
          }
        }
    }
    /* ====== EssBox X15 ====== */
    theveci = thevec+18;
    /* ------ projection ------ */
    {
        int icoord;
        for (icoord=0; icoord<2; ++icoord) {
          if (theveci[icoord] < work->Prob.X15.l[icoord]) {
            theveci[icoord] = work->Prob.X15.l[icoord];
          }
          else if (theveci[icoord] > work->Prob.X15.u[icoord]) {
            theveci[icoord] = work->Prob.X15.u[icoord];
          }
        }
    }
    /* ====== EssBox X16 ====== */
    theveci = thevec+20;
    /* ------ projection ------ */
    {
        int icoord;
        for (icoord=0; icoord<2; ++icoord) {
          if (theveci[icoord] < work->Prob.X16.l[icoord]) {
            theveci[icoord] = work->Prob.X16.l[icoord];
          }
          else if (theveci[icoord] > work->Prob.X16.u[icoord]) {
            theveci[icoord] = work->Prob.X16.u[icoord];
          }
        }
    }
    /* ====== EssBox X17 ====== */
    theveci = thevec+22;
    /* ------ projection ------ */
    {
        int icoord;
        for (icoord=0; icoord<2; ++icoord) {
          if (theveci[icoord] < work->Prob.X17.l[icoord]) {
            theveci[icoord] = work->Prob.X17.l[icoord];
          }
          else if (theveci[icoord] > work->Prob.X17.u[icoord]) {
            theveci[icoord] = work->Prob.X17.u[icoord];
          }
        }
    }
    /* ====== EssBox X18 ====== */
    theveci = thevec+24;
    /* ------ projection ------ */
    {
        int icoord;
        for (icoord=0; icoord<2; ++icoord) {
          if (theveci[icoord] < work->Prob.X18.l[icoord]) {
            theveci[icoord] = work->Prob.X18.l[icoord];
          }
          else if (theveci[icoord] > work->Prob.X18.u[icoord]) {
            theveci[icoord] = work->Prob.X18.u[icoord];
          }
        }
    }
    /* ====== EssBox X19 ====== */
    theveci = thevec+26;
    /* ------ projection ------ */
    {
        int icoord;
        for (icoord=0; icoord<2; ++icoord) {
          if (theveci[icoord] < work->Prob.X19.l[icoord]) {
            theveci[icoord] = work->Prob.X19.l[icoord];
          }
          else if (theveci[icoord] > work->Prob.X19.u[icoord]) {
            theveci[icoord] = work->Prob.X19.u[icoord];
          }
        }
    }
    /* ====== EssBox X20 ====== */
    theveci = thevec+28;
    /* ------ projection ------ */
    {
        int icoord;
        for (icoord=0; icoord<2; ++icoord) {
          if (theveci[icoord] < work->Prob.X20.l[icoord]) {
            theveci[icoord] = work->Prob.X20.l[icoord];
          }
          else if (theveci[icoord] > work->Prob.X20.u[icoord]) {
            theveci[icoord] = work->Prob.X20.u[icoord];
          }
        }
    }
}

/* <<< oracle >>> */
static void algoInner_oracle(ex2_Work *work, ex2_Params *params, realtype *z, realtype *fval, realtype *grad) {
    realtype hz[30];
    {
        /* (hz):= (work->Prob.H)^T*(z);   // (30x30)*(30x1) */
        {
            int k;
            for (k=0; k<30; ++k) {
              hz[k] = (+work->Prob.H[k]) * z[k];
            }
        }
    }

    if (NULL!=fval) {
        int i;
        realtype tmp;
        tmp = 0.0;
        for (i=0; i<30; ++i) {
          tmp += (0.5*hz[i] + work->Prob.inner_g[i]) * z[i];
        }
        fval[0] = tmp + work->Prob.inner_c[0];
    }

    if (NULL!=grad) {
        int i;
        for (i=0; i<30; ++i) {
          grad[i] = hz[i] + work->Prob.inner_g[i];
        }
    }
}
static void algoOuter_oracle(ex2_Work *work, ex2_Params *params, realtype *v, realtype *fval, realtype *grad, ex2_Settings *settings) {
    /* << data of inner problem >> */
    {
        /* (work->Prob.inner_g):= (work->Prob.Ae)^T*(v)+(params->g);   // (30x20)*(20x1),(30x1) */
        int i,k;
        realtype tmp;
        for (i=0; i<30; ++i) {
            tmp = 0.0;
            for (k=0; k<20; ++k) {
              tmp += work->Prob.Ae[k+i*20]*v[k];
            }
            work->Prob.inner_g[i] = tmp + params->g[i];
        }
    }
    {
        /* (work->Prob.inner_c):= -(v)^T*(params->be)+(params->c);   // (1x20)*(20x1),(1x1) */
        int k;
        realtype tmp;
            tmp = 0.0;
            for (k=0; k<20; ++k) {
              tmp -= v[k]*params->be[k];
            }
            work->Prob.inner_c[0] = tmp + params->c[0];
    }

    /* << inner algorithm >> */
    /* AlgoFgm */
    {
        int stopgNext;
        stopgNext = 1;
        work->algoInner.res_stopcode = 0;
        {
            realtype z[30];
            realtype zp[30];
            realtype y[30];
            realtype grad[30];
            int iter;
            int icoord;
            realtype alpha,alpha_p;
            realtype aamul,muLinv;
            realtype beta;
            
            iter =0;
            
            copyvec30(z,work->algoInner.init);  /* (z):=(work->algoInner.init) */
            copyvec30(y,z);  /* (y):=(z) */
            alpha = 1;
            muLinv = work->algoInner.glob_mu*work->algoInner.glob_Linv;
            copyvec30(zp,z);  /* (zp):=(z) */
            
            while (iter<settings->algoInner.maxit) {
                ++iter;
            
                algoInner_oracle(work,params,y,NULL,grad);
                for (icoord=0; icoord<30; ++icoord) {
                    zp[icoord] = y[icoord] - work->algoInner.glob_Linv*grad[icoord];
                }
                algoInner_project(zp,work,params);
            
                if (iter==stopgNext) {
                    int icoord;
                    realtype gradmapi;
                    realtype normsq;
                    normsq = 0;
                    for (icoord=0; icoord<30; ++icoord) {
                        gradmapi=(y[icoord]-zp[icoord]);
                        normsq += gradmapi * gradmapi;
                    }
                    normsq *= 1.0/(work->algoInner.glob_Linv*work->algoInner.glob_Linv);
                    if ( settings->algoInner.stopgEps>=0 && normsq <= settings->algoInner.stopgEps * settings->algoInner.stopgEps ) {
                        work->algoInner.res_stopcode = 2;
                        break;
                    }
                    stopgNext += settings->algoInner.stopgStride;
                }
            
                aamul = alpha*alpha - muLinv;
                alpha_p= -0.5 * aamul + sqrt( aamul*aamul * 0.25 + alpha*alpha);
                beta = alpha*(1-alpha)/(alpha*alpha+alpha_p);
            
                for (icoord=0; icoord<30; ++icoord) {
                    y[icoord] = zp[icoord] + beta*(zp[icoord]-z[icoord]);
                }
            
                copyvec30(z,zp);  /* (z):=(zp) */
                alpha = alpha_p;
            }
            copyvec30(work->algoInner.res_z,zp);  /* (work->algoInner.res_z):=(zp) */
            work->algoInner.res_iter = iter;
        }
    }

    /* << outer gradient >> */
    if (NULL!=grad) {
        {
            /* (grad):= (work->Prob.Ae)*(work->algoInner.res_z)-(params->be);   // (20x30)*(30x1),(20x1) */
            int i,k;
            realtype tmp;
            for (i=0; i<20; ++i) {
                tmp = 0.0;
                for (k=0; k<30; ++k) {
                  tmp += work->Prob.Ae[i+k*20]*work->algoInner.res_z[k];
                }
                grad[i] = tmp - params->be[i];
            }
        }
    }

    /* << dual function value >> */
    if (NULL!=fval) {
        algoInner_oracle(work,params,work->algoInner.res_z,fval,NULL);
    }

}

/* <<< SOLVE >>> */
void ex2_solve(ex2_Params *params, ex2_Settings *settings, ex2_Result *result, ex2_Work *work) {

    /* << prepare data >> */
    {
        /* === initial points === */
        copyvec30(work->algoInner.init,settings->algoInner.init);  /* (work->algoInner.init):=(settings->algoInner.init) */
        algoInner_project(work->algoInner.init,work,params);
        copyvec20(work->algoOuter.init,settings->algoOuter.init);  /* (work->algoOuter.init):=(settings->algoOuter.init) */
        
    }

    /* << main algorithm >> */
    /* AlgoFgm */
    {
        int stopgNext;
        stopgNext = 1;
        work->algoOuter.res_stopcode = 0;
        {
            realtype z[20];
            realtype zp[20];
            realtype y[20];
            realtype grad[20];
            int iter;
            int icoord;
            realtype alpha,alpha_p;
            realtype beta;
            
            iter =0;
            
            copyvec20(z,work->algoOuter.init);  /* (z):=(work->algoOuter.init) */
            copyvec20(y,z);  /* (y):=(z) */
            alpha = 1;
            copyvec20(zp,z);  /* (zp):=(z) */
            
            while (iter<settings->algoOuter.maxit) {
                ++iter;
            
                algoOuter_oracle(work,params,y,NULL,grad,settings);
                if ( 1==settings->approach.warmstartInner) {  /* reinit inner */
                    copyvec30(work->algoInner.init,work->algoInner.res_z);  /* (work->algoInner.init):=(work->algoInner.res_z) */
                }
                for (icoord=0; icoord<20; ++icoord) {
                    zp[icoord] = y[icoord] + work->algoOuter.glob_Linv*grad[icoord];
                }
            
                if (iter==stopgNext) {
                    int icoord;
                    realtype gradmapi;
                    realtype normsq;
                    normsq = 0;
                    for (icoord=0; icoord<20; ++icoord) {
                        gradmapi=(y[icoord]-zp[icoord]);
                        normsq += gradmapi * gradmapi;
                    }
                    normsq *= 1.0/(work->algoOuter.glob_Linv*work->algoOuter.glob_Linv);
                    if ( settings->algoOuter.stopgEps>=0 && normsq <= settings->algoOuter.stopgEps * settings->algoOuter.stopgEps ) {
                        work->algoOuter.res_stopcode = 2;
                        break;
                    }
                    stopgNext += settings->algoOuter.stopgStride;
                }
            
                alpha_p= 0.5*alpha*(sqrt(alpha*alpha+4)-alpha);
                beta = alpha*(1-alpha)/(alpha*alpha+alpha_p);
            
                for (icoord=0; icoord<20; ++icoord) {
                    y[icoord] = zp[icoord] + beta*(zp[icoord]-z[icoord]);
                }
            
                copyvec20(z,zp);  /* (z):=(zp) */
                alpha = alpha_p;
            }
            copyvec20(work->algoOuter.res_z,zp);  /* (work->algoOuter.res_z):=(zp) */
            work->algoOuter.res_iter = iter;
        }
    }
    
    
    /* << finalize result >> */
    copyvec20(result->la,work->algoOuter.res_z);  /* (result->la):=(work->algoOuter.res_z) */
    algoOuter_oracle(work,params,work->algoOuter.res_z,&(result->d),NULL,settings);
    copyvec30(result->x,work->algoInner.res_z);  /* (result->x):=(work->algoInner.res_z) */
    result->iter = work->algoOuter.res_iter;
    result->exitflag = work->algoOuter.res_stopcode;

}



/* <<< INIT >>> */
void ex2_init(ex2_Params *params, ex2_Settings *settings, ex2_Result *result, ex2_Work *work) {
work->Prob.H[0] = (realtype) 1.0000000000000000e+00;
work->Prob.H[1] = (realtype) 1.0000000000000000e+00;
work->Prob.H[2] = (realtype) 1.0000000000000000e+00;
work->Prob.H[3] = (realtype) 1.0000000000000000e+00;
work->Prob.H[4] = (realtype) 1.0000000000000000e+00;
work->Prob.H[5] = (realtype) 1.0000000000000000e+00;
work->Prob.H[6] = (realtype) 1.0000000000000000e+00;
work->Prob.H[7] = (realtype) 1.0000000000000000e+00;
work->Prob.H[8] = (realtype) 1.0000000000000000e+00;
work->Prob.H[9] = (realtype) 1.0000000000000000e+00;
work->Prob.H[10] = (realtype) 1.0000000000000000e+00;
work->Prob.H[11] = (realtype) 1.0000000000000000e+00;
work->Prob.H[12] = (realtype) 1.0000000000000000e+00;
work->Prob.H[13] = (realtype) 1.0000000000000000e+00;
work->Prob.H[14] = (realtype) 1.0000000000000000e+00;
work->Prob.H[15] = (realtype) 1.0000000000000000e+00;
work->Prob.H[16] = (realtype) 1.0000000000000000e+00;
work->Prob.H[17] = (realtype) 1.0000000000000000e+00;
work->Prob.H[18] = (realtype) 1.0000000000000000e+00;
work->Prob.H[19] = (realtype) 1.0000000000000000e+00;
work->Prob.H[20] = (realtype) 1.0000000000000000e+00;
work->Prob.H[21] = (realtype) 1.0000000000000000e+00;
work->Prob.H[22] = (realtype) 1.0000000000000000e+00;
work->Prob.H[23] = (realtype) 1.0000000000000000e+00;
work->Prob.H[24] = (realtype) 1.0000000000000000e+00;
work->Prob.H[25] = (realtype) 1.0000000000000000e+00;
work->Prob.H[26] = (realtype) 1.0000000000000000e+00;
work->Prob.H[27] = (realtype) 1.0000000000000000e+00;
work->Prob.H[28] = (realtype) 1.0000000000000000e+00;
work->Prob.H[29] = (realtype) 1.0000000000000000e+00;
{int i; for (i=0;i<600;++i) {work->Prob.Ae[i] = (realtype) 0.0;}}
work->Prob.Ae[0] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[1] = (realtype) -2.0000000000000000e+00;
work->Prob.Ae[22] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[23] = (realtype) -2.0000000000000000e+00;
work->Prob.Ae[44] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[45] = (realtype) -2.0000000000000000e+00;
work->Prob.Ae[66] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[67] = (realtype) -2.0000000000000000e+00;
work->Prob.Ae[88] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[89] = (realtype) -2.0000000000000000e+00;
work->Prob.Ae[110] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[111] = (realtype) -2.0000000000000000e+00;
work->Prob.Ae[132] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[133] = (realtype) -2.0000000000000000e+00;
work->Prob.Ae[154] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[155] = (realtype) -2.0000000000000000e+00;
work->Prob.Ae[176] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[177] = (realtype) -2.0000000000000000e+00;
work->Prob.Ae[198] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[199] = (realtype) -2.0000000000000000e+00;
work->Prob.Ae[200] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[202] = (realtype) -8.0000000000000004e-01;
work->Prob.Ae[221] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[222] = (realtype) -1.0000000000000000e+00;
work->Prob.Ae[223] = (realtype) -9.0000000000000002e-01;
work->Prob.Ae[242] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[244] = (realtype) -8.0000000000000004e-01;
work->Prob.Ae[263] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[264] = (realtype) -1.0000000000000000e+00;
work->Prob.Ae[265] = (realtype) -9.0000000000000002e-01;
work->Prob.Ae[284] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[286] = (realtype) -8.0000000000000004e-01;
work->Prob.Ae[305] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[306] = (realtype) -1.0000000000000000e+00;
work->Prob.Ae[307] = (realtype) -9.0000000000000002e-01;
work->Prob.Ae[326] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[328] = (realtype) -8.0000000000000004e-01;
work->Prob.Ae[347] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[348] = (realtype) -1.0000000000000000e+00;
work->Prob.Ae[349] = (realtype) -9.0000000000000002e-01;
work->Prob.Ae[368] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[370] = (realtype) -8.0000000000000004e-01;
work->Prob.Ae[389] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[390] = (realtype) -1.0000000000000000e+00;
work->Prob.Ae[391] = (realtype) -9.0000000000000002e-01;
work->Prob.Ae[410] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[412] = (realtype) -8.0000000000000004e-01;
work->Prob.Ae[431] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[432] = (realtype) -1.0000000000000000e+00;
work->Prob.Ae[433] = (realtype) -9.0000000000000002e-01;
work->Prob.Ae[452] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[454] = (realtype) -8.0000000000000004e-01;
work->Prob.Ae[473] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[474] = (realtype) -1.0000000000000000e+00;
work->Prob.Ae[475] = (realtype) -9.0000000000000002e-01;
work->Prob.Ae[494] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[496] = (realtype) -8.0000000000000004e-01;
work->Prob.Ae[515] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[516] = (realtype) -1.0000000000000000e+00;
work->Prob.Ae[517] = (realtype) -9.0000000000000002e-01;
work->Prob.Ae[536] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[538] = (realtype) -8.0000000000000004e-01;
work->Prob.Ae[557] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[558] = (realtype) -1.0000000000000000e+00;
work->Prob.Ae[559] = (realtype) -9.0000000000000002e-01;
work->Prob.Ae[578] = (realtype) 1.0000000000000000e+00;
work->Prob.Ae[599] = (realtype) 1.0000000000000000e+00;
work->Prob.X1.l[0] = (realtype) -7.0000000000000000e+00;
work->Prob.X1.u[0] = (realtype) 7.0000000000000000e+00;
work->Prob.X2.l[0] = (realtype) -7.0000000000000000e+00;
work->Prob.X2.u[0] = (realtype) 7.0000000000000000e+00;
work->Prob.X3.l[0] = (realtype) -7.0000000000000000e+00;
work->Prob.X3.u[0] = (realtype) 7.0000000000000000e+00;
work->Prob.X4.l[0] = (realtype) -7.0000000000000000e+00;
work->Prob.X4.u[0] = (realtype) 7.0000000000000000e+00;
work->Prob.X5.l[0] = (realtype) -7.0000000000000000e+00;
work->Prob.X5.u[0] = (realtype) 7.0000000000000000e+00;
work->Prob.X6.l[0] = (realtype) -7.0000000000000000e+00;
work->Prob.X6.u[0] = (realtype) 7.0000000000000000e+00;
work->Prob.X7.l[0] = (realtype) -7.0000000000000000e+00;
work->Prob.X7.u[0] = (realtype) 7.0000000000000000e+00;
work->Prob.X8.l[0] = (realtype) -7.0000000000000000e+00;
work->Prob.X8.u[0] = (realtype) 7.0000000000000000e+00;
work->Prob.X9.l[0] = (realtype) -7.0000000000000000e+00;
work->Prob.X9.u[0] = (realtype) 7.0000000000000000e+00;
work->Prob.X10.l[0] = (realtype) -7.0000000000000000e+00;
work->Prob.X10.u[0] = (realtype) 7.0000000000000000e+00;
work->Prob.X11.l[0] = (realtype) -3.5000000000000000e+00;
work->Prob.X11.l[1] = (realtype) -2.5000000000000000e+00;
work->Prob.X11.u[0] = (realtype) 3.5000000000000000e+00;
work->Prob.X11.u[1] = (realtype) 2.5000000000000000e+00;
work->Prob.X12.l[0] = (realtype) -3.5000000000000000e+00;
work->Prob.X12.l[1] = (realtype) -2.5000000000000000e+00;
work->Prob.X12.u[0] = (realtype) 3.5000000000000000e+00;
work->Prob.X12.u[1] = (realtype) 2.5000000000000000e+00;
work->Prob.X13.l[0] = (realtype) -3.5000000000000000e+00;
work->Prob.X13.l[1] = (realtype) -2.5000000000000000e+00;
work->Prob.X13.u[0] = (realtype) 3.5000000000000000e+00;
work->Prob.X13.u[1] = (realtype) 2.5000000000000000e+00;
work->Prob.X14.l[0] = (realtype) -3.5000000000000000e+00;
work->Prob.X14.l[1] = (realtype) -2.5000000000000000e+00;
work->Prob.X14.u[0] = (realtype) 3.5000000000000000e+00;
work->Prob.X14.u[1] = (realtype) 2.5000000000000000e+00;
work->Prob.X15.l[0] = (realtype) -3.5000000000000000e+00;
work->Prob.X15.l[1] = (realtype) -2.5000000000000000e+00;
work->Prob.X15.u[0] = (realtype) 3.5000000000000000e+00;
work->Prob.X15.u[1] = (realtype) 2.5000000000000000e+00;
work->Prob.X16.l[0] = (realtype) -3.5000000000000000e+00;
work->Prob.X16.l[1] = (realtype) -2.5000000000000000e+00;
work->Prob.X16.u[0] = (realtype) 3.5000000000000000e+00;
work->Prob.X16.u[1] = (realtype) 2.5000000000000000e+00;
work->Prob.X17.l[0] = (realtype) -3.5000000000000000e+00;
work->Prob.X17.l[1] = (realtype) -2.5000000000000000e+00;
work->Prob.X17.u[0] = (realtype) 3.5000000000000000e+00;
work->Prob.X17.u[1] = (realtype) 2.5000000000000000e+00;
work->Prob.X18.l[0] = (realtype) -3.5000000000000000e+00;
work->Prob.X18.l[1] = (realtype) -2.5000000000000000e+00;
work->Prob.X18.u[0] = (realtype) 3.5000000000000000e+00;
work->Prob.X18.u[1] = (realtype) 2.5000000000000000e+00;
work->Prob.X19.l[0] = (realtype) -3.5000000000000000e+00;
work->Prob.X19.l[1] = (realtype) -2.5000000000000000e+00;
work->Prob.X19.u[0] = (realtype) 3.5000000000000000e+00;
work->Prob.X19.u[1] = (realtype) 2.5000000000000000e+00;
work->Prob.X20.l[0] = (realtype) -3.5000000000000000e+00;
work->Prob.X20.l[1] = (realtype) -2.5000000000000000e+00;
work->Prob.X20.u[0] = (realtype) 3.5000000000000000e+00;
work->Prob.X20.u[1] = (realtype) 2.5000000000000000e+00;
work->algoInner.glob_Linv = (realtype) 1.0000000000000000e+00;
work->algoInner.glob_mu = (realtype) 1.0000000000000000e+00;
work->algoOuter.glob_Linv = (realtype) 1.3212472892157220e-01;
settings->approach.warmstartInner = 1;
{int i; for (i=0;i<30;++i) {settings->algoInner.init[i] = (realtype) 0.0;}}
settings->algoInner.maxit = 5000;
settings->algoInner.stopgEps = (realtype) 1.0000000000000000e-03;
settings->algoInner.stopgStride = 1;
{int i; for (i=0;i<20;++i) {settings->algoOuter.init[i] = (realtype) 0.0;}}
settings->algoOuter.maxit = 5000;
settings->algoOuter.stopgEps = (realtype) 1.0000000000000000e-03;
settings->algoOuter.stopgStride = 1;
}

